{"version":3,"sources":["webpack:///./node_modules/ngx-hm-carousel/fesm5/ngx-hm-carousel.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsD;AACuD;AACL;AAC5B;AAC+K;AAC3L;;AAEhE;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS,OAAO,uDAAS;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,gEAAgE;AAChE,SAAS,OAAO,8DAAgB,EAAE;AAClC,SAAS,OAAO,yDAAW;AAC3B,MAAM;AACN;AACA,iBAAiB,OAAO,mDAAK,mCAAmC;AAChE,kBAAkB,OAAO,mDAAK,yCAAyC;AACvE,oBAAoB,OAAO,mDAAK,wCAAwC;AACxE;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,uDAAS;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,6DAA6D,WAAW;AACxE;AACA,CAAC;;AAED;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,0BAA0B,YAAY;AACtC,eAAe,EAAE;AACjB;AACA,WAAW,+CAAU;AACrB,0BAA0B,gEAAc;AACxC;AACA,SAAS;AACT;AACA,KAAK,OAAO,mEAAY,QAAQ,0DAAG;AACnC;AACA,KAAK,GAAG,+DAAQ;AAChB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAK,CAAC,sDAAS,6BAA6B,sDAAS,mCAAmC,0DAAG;AACpH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAe;AAC1C,+BAA+B,oDAAe;AAC9C,6BAA6B,4CAAO;AACpC,4BAA4B,4CAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,+BAA+B,EAAE;AACtD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,sBAAsB,EAAE;AAC7C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,2BAA2B,EAAE;AAClD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,4BAA4B,EAAE;AACnD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,qDAAqD,EAAE;AACvD;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,gBAAgB,yEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uCAAuC,EAAE;AAC9D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,mCAAmC,EAAE;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB,yEAAiB;AACrC,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA,QAAQ,qDAAQ;AAChB;AACA;AACA;AACA,QAAQ,0DAAG;AACX;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,0DAAG,cAAc,kCAAkC,EAAE,gDAAgD,gCAAgC,EAAE,QAAQ,gEAAS;AACpK;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,mBAAmB,oBAAoB;AACvC;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,mBAAmB;AAC1C,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oEAAoE,wBAAwB,EAAE;AAC9F,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,6BAA6B,kDAAK,aAAa,sDAAS;AACxD;AACA;AACA,gBAAgB,6DAAM,cAAc,wBAAwB,EAAE,GAAG,0DAAG,cAAc,uCAAuC,EAAE;AAC3H,4BAA4B,kDAAK,YAAY,sDAAS,uCAAuC,0DAAG,cAAc,sCAAsC,EAAE;AACtJ;AACA;AACA;AACA;AACA,YAAY,gEAAS,cAAc,0BAA0B,EAAE,GAAG,gEAAS;AAC3E,uBAAuB,kDAAK,mBAAmB,gEAAS,cAAc,8BAA8B,EAAE,GAAG,0DAAG;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,gEAAS,gBAAgB,0DAAG,cAAc,gCAAgC,EAAE;AAChG,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,yEAAiB;AAC9B;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,uCAAuC,EAAE;AACzC;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,qDAAQ,CAAC,sDAAS,2CAA2C,0DAAG,cAAc,6BAA6B,EAAE,IAAI,sDAAS,2CAA2C,0DAAG,cAAc,6BAA6B,EAAE;AACxO;AACA,eAAe,+CAAE;AACjB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,qCAAqC,oBAAoB;AACzD,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA,mCAAmC,kDAAK,oBAAoB,gEAAS;AACrE;AACA;AACA;AACA;AACA,+BAA+B,kDAAK,UAAU,0DAAG;AACjD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2BAA2B,+CAAE;AAC7B,iBAAiB,GAAG,gEAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,mBAAmB,qDAAQ,mBAAmB,0DAAG;AACjD;AACA,aAAa,GAAG,kEAAW;AAC3B,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,uDAAS;AACzB;AACA,8lBAA8lB,eAAe,4GAA4G,wBAAwB,8EAA8E,WAAW;AAC10B;AACA,qCAAqC,gEAAiB;AACtD,yCAAyC,gEAAU,cAAc,+BAA+B,EAAE;AAClG;AACA,yBAAyB;AACzB,qCAAqC,qEAAuB;AAC5D,oCAAoC,cAAc,YAAY,gCAAgC,uBAAuB,2BAA2B,6BAA6B,0BAA0B,UAAU,gBAAgB,kBAAkB,WAAW,YAAY,wBAAwB,gBAAgB,YAAY,OAAO,SAAS,UAAU,kBAAkB,kBAAkB,WAAW,2BAA2B,eAAe,qBAAqB,kBAAkB,cAAc,qBAAqB,kBAAkB,YAAY,eAAe,aAAa,mBAAmB,uBAAuB,MAAM,0BAA0B,OAAO,2BAA2B,kBAAkB,QAAQ,MAAM,oBAAoB,YAAY,UAAU,wBAAwB,gBAAgB,MAAM,kBAAkB,OAAO,MAAM,QAAQ,SAAS;AACz0B,iBAAiB;AACjB;AACA;AACA,yDAAyD;AACzD,SAAS,6BAA6B,OAAO,oDAAM,SAAS,yDAAW,IAAI,GAAG;AAC9E,SAAS,gCAAgC,OAAO,oDAAM,SAAS,wDAAQ,IAAI,GAAG;AAC9E,SAAS,OAAO,uDAAS,EAAE;AAC3B,SAAS,OAAO,oDAAM,EAAE;AACxB,SAAS,OAAO,+DAAiB;AACjC,MAAM;AACN;AACA,qBAAqB,OAAO,uDAAS,2BAA2B;AAChE,mBAAmB,OAAO,uDAAS,mBAAmB;AACtD,mBAAmB,OAAO,uDAAS,mBAAmB;AACtD,gCAAgC,OAAO,uDAAS,uBAAuB;AACvE,oBAAoB,OAAO,6DAAe,sCAAsC,OAAO,wDAAU,EAAE,IAAI;AACvG,uBAAuB,OAAO,0DAAY,2BAA2B;AACrE,uBAAuB,OAAO,0DAAY,2BAA2B;AACrE,kBAAkB,OAAO,0DAAY,0BAA0B;AAC/D,uBAAuB,OAAO,0DAAY,+BAA+B;AACzE,6BAA6B,OAAO,0DAAY,+BAA+B,OAAO,8DAAgB,EAAE,IAAI;AAC5G,0BAA0B,OAAO,0DAAY,8BAA8B;AAC3E,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,mBAAmB,OAAO,mDAAK,EAAE;AACjC,oBAAoB,OAAO,mDAAK,EAAE;AAClC,wBAAwB,OAAO,mDAAK,EAAE;AACtC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,mBAAmB,OAAO,mDAAK,6BAA6B;AAC5D,wBAAwB,OAAO,mDAAK,4BAA4B;AAChE,iBAAiB,OAAO,mDAAK,4BAA4B;AACzD,qBAAqB,OAAO,mDAAK,iCAAiC;AAClE,qBAAqB,OAAO,mDAAK,yBAAyB;AAC1D,sBAAsB,OAAO,mDAAK,wBAAwB;AAC1D,sBAAsB,OAAO,mDAAK,EAAE;AACpC,uBAAuB,OAAO,mDAAK,2BAA2B;AAC9D,oBAAoB,OAAO,mDAAK,uBAAuB;AACvD,iBAAiB,OAAO,mDAAK,6BAA6B;AAC1D,mBAAmB,OAAO,mDAAK,uBAAuB;AACtD,oBAAoB,OAAO,mDAAK,uBAAuB;AACvD;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,uEAAuE;AACrF;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO,sDAAQ;AACxB;AACA,wBAAwB,4DAAY;AACpC,wBAAwB,0DAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,uEAAuE;AACrF;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;;AAEA;AACA;AACA,cAAc,uEAAuE;AACrF;;AAE0I;;AAE1I,2C;;;;;;;;;;;;ACvrCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,EAAE;AACrB,qBAAqB;AACrB;AACA;AACA,iCAAiC,YAAY;AAC7C,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC,6BAA6B,EAAE,aAAa;AAC5G,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD,mCAAmC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,iEAAiE;AACnG;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8CAA8C;AAC9C,CAAC;AACD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,yBAAyB;AACxC;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEc,oEAAK,EAAC","file":"default~chef-chef-module~customer-dashboard-customer-dashboard-module.js","sourcesContent":["import ResizeObserver from 'resize-observer-polyfill';\nimport { Observable, BehaviorSubject, forkJoin, fromEvent, interval, merge, of, Subject, timer } from 'rxjs';\nimport { debounceTime, tap, finalize, bufferCount, switchMap, takeUntil, filter } from 'rxjs/operators';\nimport { isPlatformBrowser, DOCUMENT, CommonModule } from '@angular/common';\nimport { Directive, Input, TemplateRef, ViewContainerRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, forwardRef, Inject, NgZone, PLATFORM_ID, Renderer2, ViewChild, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NgxHmCarouselDynamicDirective = /** @class */ (function () {\n    function NgxHmCarouselDynamicDirective(_view, _template) {\n        this._view = _view;\n        this._template = _template;\n        this.compelete = false;\n        this._view.clear();\n    }\n    Object.defineProperty(NgxHmCarouselDynamicDirective.prototype, \"currentI\", {\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (!this.compelete) {\n                /** @type {?} */\n                var nextI = value + 1;\n                /** @type {?} */\n                var prevI = value - 1;\n                if (this.index === 0 ||\n                    this.index === this.length - 1 ||\n                    this.index === nextI ||\n                    this.index === prevI ||\n                    this.index === value) {\n                    this._view.createEmbeddedView(this._template);\n                    this.compelete = true;\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    NgxHmCarouselDynamicDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n    };\n    NgxHmCarouselDynamicDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[ngxHmCarouselDynamic]'\n                },] }\n    ];\n    /** @nocollapse */\n    NgxHmCarouselDynamicDirective.ctorParameters = function () { return [\n        { type: ViewContainerRef },\n        { type: TemplateRef }\n    ]; };\n    NgxHmCarouselDynamicDirective.propDecorators = {\n        index: [{ type: Input, args: ['ngxHmCarouselDynamic',] }],\n        length: [{ type: Input, args: ['ngxHmCarouselDynamicLength',] }],\n        currentI: [{ type: Input, args: ['ngxHmCarouselDynamicIndex',] }]\n    };\n    return NgxHmCarouselDynamicDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NgxHmCarouselItemDirective = /** @class */ (function () {\n    function NgxHmCarouselItemDirective() {\n    }\n    NgxHmCarouselItemDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[ngx-hm-carousel-item]'\n                },] }\n    ];\n    /** @nocollapse */\n    NgxHmCarouselItemDirective.ctorParameters = function () { return []; };\n    return NgxHmCarouselItemDirective;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An observable creator for element resize.\n * @param {?} elm the watch element.\n * @param {?} cb when resize complete, call back function.\n * @param {?=} time resize emit time, default is 200\n * @return {?}\n */\nfunction resizeObservable(elm, cb, time) {\n    if (time === void 0) { time = 200; }\n    /** @type {?} */\n    var elmObserve$;\n    return Observable.create(function (observer) {\n        elmObserve$ = new ResizeObserver(function (entries, obs) {\n            observer.next(elmObserve$);\n        });\n        elmObserve$.observe(elm);\n    }).pipe(debounceTime(time), tap(function () {\n        cb();\n    }), finalize(function () {\n        elmObserve$.unobserve(elm);\n        elmObserve$.disconnect();\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// if the pane is paned .15, switch to the next pane.\n/** @type {?} */\nvar PANBOUNDARY = 0.15;\nvar NgxHmCarouselComponent = /** @class */ (function () {\n    function NgxHmCarouselComponent(platformId, _document, _renderer, _zone, _cd) {\n        var _this = this;\n        this.platformId = platformId;\n        this._document = _document;\n        this._renderer = _renderer;\n        this._zone = _zone;\n        this._cd = _cd;\n        this.aniTime = 400;\n        this.aniClass = 'transition';\n        this.aniClassAuto = this.aniClass;\n        // this default autoplay animation is same as aniClass\n        this.align = 'center';\n        this.notDrag = false;\n        this.mourseEnable = false;\n        this.delay = 8000;\n        this.direction = 'right';\n        this.scrollNum = 1;\n        this.isDragMany = false;\n        this.breakpoint = [];\n        // using for check mouse or touchend\n        this.leaveObs$ = merge(fromEvent(this._document, 'mouseup'), fromEvent(this._document, 'touchend')).pipe(tap(function (e) {\n            _this.grabbing = false;\n            e.stopPropagation();\n            e.preventDefault();\n        }));\n        this.isFromAuto = true;\n        this.isAutoNum = false;\n        this.mouseOnContainer = false;\n        this.alignDistance = 0;\n        this.elmWidth = 0;\n        this.infiniteElmRefs = [];\n        this.restart = new BehaviorSubject(null);\n        this.speedChange = new BehaviorSubject(5000);\n        this.stopEvent = new Subject();\n        this.destroy$ = new Subject();\n        this._porgressWidth = 0;\n        this._currentIndex = 0;\n        this._showNum = 1;\n        this._autoplay = false;\n        this._infinite = false;\n        this._tmpInfinite = false;\n        this._grabbing = false;\n        this.panCount = 0;\n        this._disableDrag = false;\n        // this variable use for check the init value is write with ngModel,\n        // when init first, not set with animation\n        this.hasInitWriteValue = false;\n        this.onChange = function (_) { };\n        this.onTouched = function () { };\n    }\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"disableDrag\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this._disableDrag;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (this.rootElm) {\n                if (this._disableDrag !== value) {\n                    if (value) {\n                        this.destoryHammer();\n                    }\n                    else {\n                        this.hammer = this.bindHammer();\n                    }\n                }\n            }\n            this._disableDrag = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"infinite\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._infinite; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            this._infinite = value;\n            this.infiniteElmRefs.forEach(function (ref) {\n                _this.addStyle(ref.rootNodes[0], {\n                    visibility: _this.runLoop ? 'visible' : 'hidden'\n                });\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"speed\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.speedChange.value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            this._zone.runOutsideAngular(function () {\n                _this.speedChange.next(value);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"showNum\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._showNum; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value === 'auto') {\n                this.isAutoNum = true;\n            }\n            else {\n                this._showNum = +value;\n                if (this.rootElm) {\n                    this.setViewWidth();\n                    this.reSetAlignDistance();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"autoplay\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._autoplay; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            if (isPlatformBrowser(this.platformId)) {\n                if (this.elms) {\n                    this.progressWidth = 0;\n                    if (value) {\n                        this._zone.runOutsideAngular(function () {\n                            _this.doNextSub$ = _this.doNext.subscribe();\n                        });\n                    }\n                    else {\n                        if (this.doNextSub$) {\n                            this.doNextSub$.unsubscribe();\n                        }\n                    }\n                }\n            }\n            this._autoplay = value;\n            // if set autoplay, then the infinite is true\n            if (value) {\n                this._tmpInfinite = this.infinite;\n                this.infinite = true;\n            }\n            else {\n                this.infinite = this._tmpInfinite;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"currentIndex\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._currentIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            // if now index if not equale to save index, do someting\n            if (this.currentIndex !== value) {\n                // if the value is not contain with the boundary not handler\n                if (!this.runLoop && !(0 <= value && value <= this.itemElms.length - 1)) {\n                    return;\n                }\n                this._currentIndex = value;\n                if (this.elms) {\n                    if (this.autoplay && !this.isFromAuto) {\n                        this._zone.runOutsideAngular(function () {\n                            _this.stopEvent.next();\n                            _this.callRestart();\n                        });\n                    }\n                    this.drawView(this.currentIndex, this.hasInitWriteValue);\n                    if (this.isDragMany) {\n                        this.hasInitWriteValue = true;\n                    }\n                }\n                if (0 <= this.currentIndex && this.currentIndex <= this.itemElms.length - 1) {\n                    this._zone.run(function () {\n                        _this.onChange(_this.currentIndex);\n                        _this._cd.detectChanges();\n                    });\n                }\n            }\n            this.isFromAuto = false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"progressWidth\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._porgressWidth; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (this.progressElm !== undefined && this.autoplay) {\n                this._porgressWidth = value;\n                this._renderer.setStyle(((/** @type {?} */ (this.progressContainerElm.nativeElement))).children[0], 'width', this.progressWidth + \"%\");\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"grabbing\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._grabbing; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            if (this._grabbing !== value) {\n                // console.log(value);\n                this._zone.run(function () {\n                    _this._grabbing = value;\n                    if (value) {\n                        _this._renderer.addClass(_this.containerElm, 'grabbing');\n                    }\n                    else {\n                        _this.panCount = 0;\n                        _this.callRestart();\n                        _this._renderer.removeClass(_this.containerElm, 'grabbing');\n                    }\n                    _this._cd.detectChanges();\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"left\", {\n        set: /**\n         * @private\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (isPlatformBrowser(this.platformId)) {\n                this._renderer.setStyle(this.containerElm, 'transform', \"translateX(\" + value + \"px)\");\n            }\n            else {\n                this._renderer.setStyle(this.containerElm, 'transform', \"translateX(\" + value + \"%)\");\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"maxRightIndex\", {\n        get: /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var addIndex = 0;\n            switch (this.align) {\n                case 'left':\n                    addIndex = 0;\n                    break;\n                case 'center':\n                    addIndex = (/** @type {?} */ (this.showNum)) - 1;\n                    break;\n                case 'right':\n                    addIndex = (/** @type {?} */ (this.showNum)) - 1;\n                    break;\n            }\n            return ((this.itemElms.length - 1) - this._showNum + 1) + addIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"runLoop\", {\n        get: /**\n         * @private\n         * @return {?}\n         */\n        function () { return this.autoplay || this.infinite; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"lengthOne\", {\n        get: /**\n         * @private\n         * @return {?}\n         */\n        function () { return this.itemElms.length === 1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"rootElmWidth\", {\n        get: /**\n         * @private\n         * @return {?}\n         */\n        function () {\n            return (isPlatformBrowser(this.platformId) ? this.rootElm.getBoundingClientRect().width : 100);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgxHmCarouselComponent.prototype, \"containerElmWidth\", {\n        set: /**\n         * @private\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this.setStyle(this.containerElm, 'width', value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.rootElm = this.container.nativeElement;\n        this.containerElm = (/** @type {?} */ (this.rootElm.children[0]));\n        this.init();\n        forkJoin(this.bindClick(), \n        // when item changed, remove old hammer binding, and reset width\n        this.itemElms.changes.pipe(\n        // detectChanges to change view dots\n        tap(function () {\n            if (_this.currentIndex > _this.itemElms.length - 1) {\n                // i can't pass the changedetection check, only the way to using timeout. :(\n                setTimeout(function () {\n                    _this.currentIndex = _this.itemElms.length - 1;\n                }, 0);\n            }\n            _this.destroy();\n            _this.removeInfiniteElm();\n            _this.init();\n            _this.progressWidth = 0;\n        }), tap(function () { return _this._cd.detectChanges(); })), resizeObservable(this.rootElm, function () { return _this.containerResize(); })).pipe(takeUntil(this.destroy$)).subscribe();\n    };\n    /**\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.destroy();\n        this.destroy$.next();\n        this.destroy$.unsubscribe();\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        if (value || value === 0) {\n            this.currentIndex = value;\n            this.hasInitWriteValue = true;\n        }\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this.onChange = fn; };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) { this.onTouched = fn; };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.init = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.initVariable();\n        this.setViewWidth(true);\n        this.reSetAlignDistance();\n        if (!this.disableDrag) {\n            this.hammer = this.bindHammer();\n        }\n        this.drawView(this.currentIndex, false);\n        if (isPlatformBrowser(this.platformId) && this.runLoop) {\n            this.addInfiniteElm();\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.destroy = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.destoryHammer();\n        if (this.autoplay) {\n            this.doNextSub$.unsubscribe();\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.destoryHammer = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.hammer) {\n            this.hammer.destroy();\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.addInfiniteElm = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        for (var i = 1; i <= this.showNum; i++) {\n            /** @type {?} */\n            var elm = this.infiniteContainer.createEmbeddedView(this.contentContent, {\n                $implicit: this.data[this.itemElms.length - i],\n                index: this.itemElms.length - i\n            });\n            this.addStyle(elm.rootNodes[0], {\n                position: 'absolute',\n                // boxShadow: `0 0 0 5000px rgba(200, 75, 75, 0.5) inset`,\n                transform: \"translateX(-\" + 100 * i + \"%)\",\n                visibility: this.runLoop ? 'visible' : 'hidden'\n            });\n            this.setStyle(elm.rootNodes[0], 'width', this.elmWidth);\n            /** @type {?} */\n            var elm2 = this.infiniteContainer.createEmbeddedView(this.contentContent, {\n                $implicit: this.data[i - 1],\n                index: i - 1\n            });\n            this.addStyle(elm2.rootNodes[0], {\n                // boxShadow: `0 0 0 5000px rgba(200, 75, 75, 0.5) inset`,\n                position: 'absolute',\n                right: 0,\n                top: 0,\n                transform: \"translateX(\" + 100 * i + \"%)\",\n                visibility: this.runLoop ? 'visible' : 'hidden'\n            });\n            this.setStyle(elm2.rootNodes[0], 'width', this.elmWidth);\n            elm.detectChanges();\n            elm2.detectChanges();\n            this.infiniteElmRefs.push(elm);\n            this.infiniteElmRefs.push(elm2);\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.removeInfiniteElm = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.infiniteElmRefs.forEach(function (a) {\n            a.detach();\n            a.destroy();\n        });\n        if (this.infiniteContainer) {\n            this.infiniteContainer.clear();\n        }\n        this.infiniteElmRefs = [];\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.containerResize = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.setViewWidth();\n        this.reSetAlignDistance();\n        // 因為不能滑了，所以要回到第一個，以確保全部都有顯示\n        if (this.align !== 'center' && this.showNum >= this.elms.length) {\n            this.currentIndex = 0;\n        }\n        this.drawView(this.currentIndex, false);\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.initVariable = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._zone.runOutsideAngular(function () {\n            _this.elms = _this.itemElms.toArray().map(function (x) { return x.nativeElement; });\n            /** @type {?} */\n            var startEvent = _this.restart.asObservable();\n            /** @type {?} */\n            var stopEvent = _this.stopEvent.asObservable();\n            if (_this.mourseEnable) {\n                startEvent = merge(startEvent, fromEvent(_this.containerElm, 'mouseleave').pipe(\n                // when leave, we should reverse grabbing state to set the mouseOn state,\n                // because when the grabbing, the mask will on, and it will occur leave again\n                filter(function () { return !_this.grabbing; }), tap(function () { return _this.mouseOnContainer = false; })));\n                stopEvent = merge(stopEvent, fromEvent(_this.containerElm, 'mouseover').pipe(tap(function () { return _this.mouseOnContainer = true; })));\n            }\n            _this.doNext = startEvent.pipe(\n            // not using debounceTime, it will stop mourseover event detect, will cause mourse-enable error\n            // debounceTime(this.delay),\n            switchMap(function () { return _this.speedChange; }), switchMap(function () {\n                return timer(_this.delay).pipe(switchMap(function () { return _this.runProgress(20); }), tap(function () {\n                    _this.isFromAuto = true;\n                    // console.log('next');\n                    if (_this.direction === 'left') {\n                        _this.currentIndex -= _this.scrollNum;\n                    }\n                    else {\n                        _this.currentIndex += _this.scrollNum;\n                    }\n                }), takeUntil(stopEvent.pipe(tap(function () { return _this.progressWidth = 0; }))));\n            }));\n            if (_this.autoplay) {\n                _this.doNextSub$ = _this.doNext.subscribe();\n            }\n        });\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.reSetAlignDistance = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        switch (this.align) {\n            case 'center':\n                this.alignDistance = (this.rootElmWidth - this.elmWidth) / 2;\n                break;\n            case 'left':\n                this.alignDistance = 0;\n                break;\n            case 'right':\n                this.alignDistance = this.rootElmWidth - this.elmWidth;\n                break;\n        }\n    };\n    /**\n     * @private\n     * @param {?=} isInit\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.setViewWidth = /**\n     * @private\n     * @param {?=} isInit\n     * @return {?}\n     */\n    function (isInit) {\n        var _this = this;\n        if (this.isAutoNum) {\n            this._showNum = this.getAutoNum();\n        }\n        this._renderer.addClass(this.containerElm, 'grab');\n        if (isInit) {\n            // remain one elm height\n            this._renderer.addClass(this.containerElm, 'ngx-hm-carousel-display-npwrap');\n        }\n        this.elmWidth = this.rootElmWidth / this._showNum;\n        this._renderer.removeClass(this.containerElm, 'ngx-hm-carousel-display-npwrap');\n        this.containerElmWidth = this.elmWidth * this.elms.length;\n        this._renderer.setStyle(this.containerElm, 'position', 'relative');\n        this.infiniteElmRefs.forEach(function (ref) {\n            _this.setStyle(ref.rootNodes[0], 'width', _this.elmWidth);\n        });\n        this.elms.forEach(function (elm) {\n            _this.setStyle(elm, 'width', _this.elmWidth);\n        });\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.bindHammer = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!isPlatformBrowser(this.platformId)) {\n            return null;\n        }\n        return this._zone.runOutsideAngular(function () {\n            /** @type {?} */\n            var hm = new Hammer(_this.containerElm);\n            hm.get('pan').set({ direction: Hammer.DIRECTION_HORIZONTAL });\n            hm.on('panleft panright panend pancancel', function (e) {\n                // console.log(e.type);\n                if (_this.lengthOne) {\n                    return;\n                }\n                _this.removeContainerTransition();\n                if (_this.autoplay) {\n                    _this._zone.runOutsideAngular(function () { _this.stopEvent.next(); });\n                }\n                switch (e.type) {\n                    case 'panleft':\n                    case 'panright':\n                        _this.panCount++;\n                        // only when panmove more than two times, set move\n                        if (_this.panCount < 2) {\n                            return;\n                        }\n                        _this.grabbing = true;\n                        // When show-num is bigger than length, stop hammer\n                        if (_this.align !== 'center' && _this.showNum >= _this.elms.length) {\n                            _this.hammer.stop(true);\n                            return;\n                        }\n                        // Slow down at the first and last pane.\n                        if (!_this.runLoop && _this.outOfBound(e.type)) {\n                            e.deltaX *= 0.2;\n                        }\n                        if (!_this.notDrag) {\n                            _this.left = -_this.currentIndex * _this.elmWidth + _this.alignDistance + e.deltaX;\n                        }\n                        // // if not dragmany, when bigger than half\n                        if (!_this.isDragMany) {\n                            if (Math.abs(e.deltaX) > _this.elmWidth * 0.5) {\n                                if (e.deltaX > 0) {\n                                    _this.currentIndex -= _this.scrollNum;\n                                }\n                                else {\n                                    _this.currentIndex += _this.scrollNum;\n                                }\n                                _this.hammer.stop(true);\n                                return;\n                            }\n                        }\n                        break;\n                    case 'pancancel':\n                        _this.drawView(_this.currentIndex);\n                        break;\n                    case 'panend':\n                        if (Math.abs(e.deltaX) > _this.elmWidth * PANBOUNDARY) {\n                            /** @type {?} */\n                            var moveNum = _this.isDragMany ?\n                                Math.ceil(Math.abs(e.deltaX) / _this.elmWidth) : _this.scrollNum;\n                            /** @type {?} */\n                            var prevIndex = _this.currentIndex - moveNum;\n                            /** @type {?} */\n                            var nextIndex = _this.currentIndex + moveNum;\n                            // if right\n                            if (e.deltaX > 0) {\n                                if (!_this.runLoop && prevIndex < 0) {\n                                    prevIndex = 0;\n                                    _this.drawView(0);\n                                }\n                                _this.currentIndex = prevIndex;\n                                // left\n                            }\n                            else {\n                                if (!_this.runLoop && nextIndex > _this.maxRightIndex) {\n                                    nextIndex = _this.maxRightIndex;\n                                    _this.drawView(nextIndex);\n                                }\n                                _this.currentIndex = nextIndex;\n                            }\n                            break;\n                        }\n                        _this.drawView(_this.currentIndex);\n                        break;\n                }\n            });\n            return hm;\n        });\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.bindClick = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this.btnNext && this.btnPrev) {\n            return forkJoin(fromEvent(this.btnNext.nativeElement, 'click').pipe(tap(function () { return _this.currentIndex++; })), fromEvent(this.btnPrev.nativeElement, 'click').pipe(tap(function () { return _this.currentIndex--; })));\n        }\n        return of(null);\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.callRestart = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // if that is autoplay\n        // if that mouse is not on container( only mouse-enable is true, the state maybe true)\n        // if now is grabbing, skip this restart, using grabbing change restart\n        if (this.autoplay && !this.mouseOnContainer && !this.grabbing) {\n            this._zone.runOutsideAngular(function () {\n                _this.restart.next(null);\n            });\n        }\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @param {?=} isAnimation\n     * @param {?=} isFromAuto\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.drawView = /**\n     * @private\n     * @param {?} index\n     * @param {?=} isAnimation\n     * @param {?=} isFromAuto\n     * @return {?}\n     */\n    function (index, isAnimation, isFromAuto) {\n        if (isAnimation === void 0) { isAnimation = true; }\n        if (isFromAuto === void 0) { isFromAuto = this.isFromAuto; }\n        // move element only on length is more than 1\n        if (this.elms.length > 1) {\n            this.removeContainerTransition();\n            this.left = -((index * this.elmWidth) - this.alignDistance);\n            if (isAnimation) {\n                if (isFromAuto) {\n                    this._renderer.addClass(this.containerElm, this.aniClassAuto);\n                }\n                else {\n                    this._renderer.addClass(this.containerElm, this.aniClass);\n                }\n                // if infinite move to next index with timeout\n                this.infiniteHandler(index);\n            }\n        }\n        else {\n            this.left = this.alignDistance;\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.removeContainerTransition = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this._renderer.removeClass(this.containerElm, this.aniClass);\n        this._renderer.removeClass(this.containerElm, this.aniClassAuto);\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.infiniteHandler = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        var _this = this;\n        if (this.runLoop) {\n            /** @type {?} */\n            var state_1 = 0;\n            state_1 = (index < 0) ? -1 : state_1;\n            state_1 = (index > (this.itemElms.length - 1)) ? 1 : state_1;\n            // index = index % this._showNum;\n            if (state_1 !== 0) {\n                switch (state_1) {\n                    case -1:\n                        this._currentIndex = (this.itemElms.length + index) % this.itemElms.length;\n                        break;\n                    case 1:\n                        this._currentIndex = index % this.itemElms.length;\n                        break;\n                }\n                /** @type {?} */\n                var isFromAuto_1 = this.isFromAuto;\n                if (this.saveTimeOut) {\n                    this.saveTimeOut.unsubscribe();\n                }\n                this.saveTimeOut = timer(this.aniTime).pipe(switchMap(function () {\n                    // if it is any loop carousel, the next event need wait the timeout complete\n                    if (_this.aniTime === _this.speed) {\n                        _this.removeContainerTransition();\n                        _this.left = -((_this._currentIndex - state_1) * _this.elmWidth) + _this.alignDistance;\n                        return timer(50).pipe(tap(function () {\n                            _this.drawView(_this.currentIndex, _this.hasInitWriteValue, isFromAuto_1);\n                        }));\n                    }\n                    else {\n                        _this.drawView(_this.currentIndex, false);\n                    }\n                    return of(null);\n                }), takeUntil(this.stopEvent)).subscribe();\n            }\n        }\n    };\n    /**\n     * @private\n     * @param {?} type\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.outOfBound = /**\n     * @private\n     * @param {?} type\n     * @return {?}\n     */\n    function (type) {\n        switch (type) {\n            case 'panleft':\n                return this.currentIndex >= this.maxRightIndex;\n            case 'panright':\n                return this.currentIndex <= 0;\n        }\n    };\n    /**\n     * @private\n     * @param {?} betweenTime\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.runProgress = /**\n     * @private\n     * @param {?} betweenTime\n     * @return {?}\n     */\n    function (betweenTime) {\n        var _this = this;\n        return this._zone.runOutsideAngular(function () {\n            /** @type {?} */\n            var howTimes = _this.speed / betweenTime;\n            /** @type {?} */\n            var everyIncrease = 100 / _this.speed * betweenTime;\n            return interval(betweenTime).pipe(tap(function (t) {\n                _this.progressWidth = (t % howTimes) * everyIncrease;\n            }), bufferCount(Math.round(howTimes), 0));\n        });\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.getAutoNum = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var curr_width = this.rootElmWidth;\n        // check user has had set breakpoint\n        if (this.breakpoint.length > 0) {\n            // get the last bigget point\n            /** @type {?} */\n            var now = this.breakpoint.find(function (b) {\n                return b.width >= curr_width;\n            });\n            // if find value, it is current width\n            if (now) {\n                return now.number;\n            }\n            return this.breakpoint[this.breakpoint.length - 1].number;\n        }\n        // system init show number\n        /** @type {?} */\n        var initNum = 3;\n        // 610\n        if (curr_width > 300) {\n            return Math.floor(initNum + (curr_width / 200));\n        }\n        return initNum;\n    };\n    /**\n     * @private\n     * @param {?} elm\n     * @param {?} style\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.addStyle = /**\n     * @private\n     * @param {?} elm\n     * @param {?} style\n     * @return {?}\n     */\n    function (elm, style) {\n        var _this = this;\n        if (style) {\n            Object.keys(style).forEach(function (key) {\n                /** @type {?} */\n                var value = style[key];\n                _this._renderer.setStyle(elm, key, value);\n            });\n        }\n    };\n    /**\n     * @private\n     * @param {?} elm\n     * @param {?} style\n     * @param {?} value\n     * @return {?}\n     */\n    NgxHmCarouselComponent.prototype.setStyle = /**\n     * @private\n     * @param {?} elm\n     * @param {?} style\n     * @param {?} value\n     * @return {?}\n     */\n    function (elm, style, value) {\n        if (isPlatformBrowser(this.platformId)) {\n            this._renderer.setStyle(elm, style, value + \"px\");\n        }\n        else {\n            this._renderer.setStyle(elm, style, value + \"%\");\n        }\n    };\n    NgxHmCarouselComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'ngx-hm-carousel',\n                    template: \"<div #containerElm class=\\\"carousel\\\">\\n  <!-- main content -->\\n  <ng-content select=\\\"[ngx-hm-carousel-container]\\\"></ng-content>\\n  <!-- left -->\\n  <div #prev *ngIf=\\\"contentPrev\\\"\\n    class=\\\"direction left\\\">\\n    <ng-container *ngTemplateOutlet=\\\"contentPrev\\\"></ng-container>\\n  </div>\\n  <!--  right -->\\n  <div #next *ngIf=\\\"contentNext\\\"\\n    class=\\\"direction right\\\">\\n    <ng-container *ngTemplateOutlet=\\\"contentNext\\\"></ng-container>\\n  </div>\\n  <!-- indicators -->\\n  <ul class=\\\"indicators\\\" *ngIf=\\\"dotElm\\\">\\n    <li\\n      *ngFor=\\\"let dot of itemElms; let i = index;\\\"\\n      (click)=\\\"currentIndex = i\\\">\\n      <ng-container\\n        *ngTemplateOutlet=\\\"dotElm, context: {\\n          $implicit: {\\n            index : i,\\n            currentIndex : currentIndex\\n          }\\n        }\\\">\\n      </ng-container>\\n    </li>\\n  </ul>\\n  <!-- progress -->\\n  <div *ngIf=\\\"progressElm && autoplay\\\" #progress>\\n    <ng-container\\n      *ngTemplateOutlet=\\\"progressElm\\\">\\n    </ng-container>\\n  </div>\\n\\n  <div class=\\\"mask\\\" *ngIf=\\\"grabbing\\\">\\n    <ng-container *ngIf=\\\"leaveObs$ | async\\\"></ng-container>\\n  </div>\\n</div>\\n\",\n                    providers: [{\n                            provide: NG_VALUE_ACCESSOR,\n                            useExisting: forwardRef(function () { return NgxHmCarouselComponent; }),\n                            multi: true\n                        }],\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    styles: [\":host{display:block;height:100%}.ngx-hm-carousel-display-npwrap{display:flex!important;flex-wrap:nowrap!important;flex-direction:row!important;overflow:hidden!important}.carousel{overflow:hidden;position:relative;width:100%;height:100%}.carousel ul.indicators{list-style:none;bottom:1rem;left:0;margin:0;padding:0;position:absolute;text-align:center;width:100%}.carousel ul.indicators li{cursor:pointer;display:inline-block;position:relative;padding:.5rem}.carousel .direction{position:absolute;height:100%;cursor:pointer;display:flex;align-items:center;justify-content:center;top:0}.carousel .direction.left{left:0}.carousel .direction.right{position:absolute;right:0}.grab{cursor:-webkit-grab;cursor:grab}.grabbing{cursor:-webkit-grabbing;cursor:grabbing}.mask{position:absolute;left:0;top:0;right:0;bottom:0}\"]\n                }] }\n    ];\n    /** @nocollapse */\n    NgxHmCarouselComponent.ctorParameters = function () { return [\n        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n        { type: Renderer2 },\n        { type: NgZone },\n        { type: ChangeDetectorRef }\n    ]; };\n    NgxHmCarouselComponent.propDecorators = {\n        container: [{ type: ViewChild, args: ['containerElm',] }],\n        btnPrev: [{ type: ViewChild, args: ['prev',] }],\n        btnNext: [{ type: ViewChild, args: ['next',] }],\n        progressContainerElm: [{ type: ViewChild, args: ['progress',] }],\n        itemElms: [{ type: ContentChildren, args: [NgxHmCarouselItemDirective, { read: ElementRef },] }],\n        contentPrev: [{ type: ContentChild, args: ['carouselPrev',] }],\n        contentNext: [{ type: ContentChild, args: ['carouselNext',] }],\n        dotElm: [{ type: ContentChild, args: ['carouselDot',] }],\n        progressElm: [{ type: ContentChild, args: ['carouselProgress',] }],\n        infiniteContainer: [{ type: ContentChild, args: ['infiniteContainer', { read: ViewContainerRef },] }],\n        contentContent: [{ type: ContentChild, args: ['carouselContent',] }],\n        data: [{ type: Input }],\n        aniTime: [{ type: Input }],\n        aniClass: [{ type: Input }],\n        aniClassAuto: [{ type: Input }],\n        align: [{ type: Input }],\n        notDrag: [{ type: Input, args: ['not-follow-pan',] }],\n        mourseEnable: [{ type: Input, args: ['mourse-enable',] }],\n        delay: [{ type: Input, args: ['between-delay',] }],\n        direction: [{ type: Input, args: ['autoplay-direction',] }],\n        scrollNum: [{ type: Input, args: ['scroll-num',] }],\n        isDragMany: [{ type: Input, args: ['drag-many',] }],\n        breakpoint: [{ type: Input }],\n        disableDrag: [{ type: Input, args: ['disable-drag',] }],\n        infinite: [{ type: Input, args: ['infinite',] }],\n        speed: [{ type: Input, args: ['autoplay-speed',] }],\n        showNum: [{ type: Input, args: ['show-num',] }],\n        autoplay: [{ type: Input, args: ['autoplay',] }]\n    };\n    return NgxHmCarouselComponent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar NgxHmCarouselModule = /** @class */ (function () {\n    function NgxHmCarouselModule() {\n    }\n    NgxHmCarouselModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [\n                        CommonModule,\n                        FormsModule,\n                    ],\n                    declarations: [\n                        NgxHmCarouselComponent,\n                        NgxHmCarouselDynamicDirective,\n                        NgxHmCarouselItemDirective\n                    ],\n                    exports: [\n                        NgxHmCarouselComponent,\n                        NgxHmCarouselDynamicDirective,\n                        NgxHmCarouselItemDirective\n                    ]\n                },] }\n    ];\n    return NgxHmCarouselModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { NgxHmCarouselDynamicDirective, NgxHmCarouselComponent, NgxHmCarouselModule, resizeObservable, NgxHmCarouselItemDirective as ɵa };\n\n//# sourceMappingURL=ngx-hm-carousel.js.map","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n"],"sourceRoot":""}